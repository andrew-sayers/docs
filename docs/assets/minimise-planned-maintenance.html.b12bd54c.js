import{_ as s,r as i,o as r,a as l,b as e,d as a,F as c,c as o,e as n}from"./app.9a3d5b6e.js";const d={},h=o('<h1 id="minimise-planned-maintenance" tabindex="-1"><a class="header-anchor" href="#minimise-planned-maintenance" aria-hidden="true">#</a> Minimise planned maintenance</h1><p>Planned maintenance is a window where we can make updates to the project that have a reasonable chance of causing problems for users or developers. For example, breaking the dashboard or causing GitHub actions to fail.</p><p>This page discusses ways to avoid planned maintenance, or at least reduce the amount of work that needs to be done during the maintenance window.</p><h2 id="general-guidelines" tabindex="-1"><a class="header-anchor" href="#general-guidelines" aria-hidden="true">#</a> General guidelines</h2><h3 id="test-on-a-personal-fork-when-possible" tabindex="-1"><a class="header-anchor" href="#test-on-a-personal-fork-when-possible" aria-hidden="true">#</a> Test on a personal fork when possible</h3><p>Sometimes you need to make changes to a repository that might fail. For example, GitHub actions generally can&#39;t be tested without being run on GitHub&#39;s own servers.</p>',6),u=n("Most changes can be made - or at least rehearsed - on a personal fork of the repository. Even if you need to test actions that look at the "),p=e("code",null,"main",-1),m=n(" branch, you can "),_={href:"https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History",target:"_blank",rel:"noopener noreferrer"},b=n("rewrite your fork's history"),g=n(" and rerun tests as often as you like."),f=e("h3",{id:"use-a-pre-release-label-for-live-testing",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#use-a-pre-release-label-for-live-testing","aria-hidden":"true"},"#"),n(" Use a "),e("code",null,"pre-release"),n(" label for live testing")],-1),k=n("Sometimes you need to build a package and push it to an external site. For example, you might want to build a new dev server and push an image to "),y={href:"https://hub.docker.com/u/sleepdiaryproject",target:"_blank",rel:"noopener noreferrer"},v=n("our Docker Hub site"),w=n("."),x=n("Most sites let you push pre-release versions of packages. In particular, packages that use "),P={href:"https://semver.org/",target:"_blank",rel:"noopener noreferrer"},R=n("semantic versioning"),T=n(" should use pre-release labels like "),q=e("code",null,"1.2.3-$COMMIT",-1),F=n(", while continuously-deployed packages should use a channel called "),j=e("code",null,"pre-release",-1),H=n("."),M=o(`<p>When you&#39;ve finished with the pre-release, you might be able to publish simply by relabelling it. Otherwise, you&#39;ll have to spend a little longer pushing the same binary again.</p><h3 id="use-guard-lines-to-avoid-merge-conflicts" tabindex="-1"><a class="header-anchor" href="#use-guard-lines-to-avoid-merge-conflicts" aria-hidden="true">#</a> Use guard lines to avoid merge conflicts</h3><p>Sometimes you need to manage changes that <code>git</code> can&#39;t merge automatically. For example, most repositories have a <code>.gitignore</code> file with lines in the <code>main</code> branch that are missing in the <code>built</code> branch.</p><p>Most merge conflicts can be avoided with a <em>guard line</em> for <code>git</code> to use:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;This line appears in one branch&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* this guard line appears in both branches */</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;This line appears in another branch&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Now you can modify or delete either line in either branch, and <code>git</code> will use the guard line to merge them automatically.</p><h2 id="specific-procedures" tabindex="-1"><a class="header-anchor" href="#specific-procedures" aria-hidden="true">#</a> Specific procedures</h2><h3 id="run-a-planned-maintenance" tabindex="-1"><a class="header-anchor" href="#run-a-planned-maintenance" aria-hidden="true">#</a> Run a planned maintenance</h3>`,8),G={href:"https://github.com/sleepdiary/internal-tools/issues/new?assignees=&labels=planned-maintenance&template=planned-maintenance.md&title=Planned+maintenance%3A+TODO%3A+purpose+of+this+maintenance",target:"_blank",rel:"noopener noreferrer"},I=n("Create a new maintenance issue"),N=n(" and follow the steps described in the template."),O=o('<h3 id="fix-a-built-branch" tabindex="-1"><a class="header-anchor" href="#fix-a-built-branch" aria-hidden="true">#</a> Fix a <code>built</code> branch</h3><p>When you have a merge failure in the <code>built</code> branch, see if you can fix it with a guard line. If so, use the following procedure:</p><ol><li>create a PR in the <code>main</code> branch that adds a guard line but <em>does not</em> include the conflicting PR</li><li>merge the guard line into the <code>built</code> branch</li><li>rebase the conflicting PR on top of the new <code>main</code> branch</li><li>accept the (no longer conflicting) PR</li></ol><p>If you can resolve a merge conflict with the procedure above, there&#39;s no need to schedule a planned maintenance. Otherwise:</p>',4),S=e("li",null,[n("create a new PR that merges the existing PR into the "),e("code",null,"built"),n(" branch")],-1),A=e("li",null,"test both thoroughly in a personal repo",-1),E=n("once everything works, "),V={href:"https://github.com/sleepdiary/internal-tools/issues/new?assignees=&labels=planned-maintenance&template=planned-maintenance.md&title=Planned+maintenance%3A+Fix+the+built+branch",target:"_blank",rel:"noopener noreferrer"},B=n("create a new planned maintenance issue"),C=n(" with steps like: "),U=e("ol",null,[e("li",null,[n("merge the "),e("code",null,"built"),n(" PR into main first")]),e("li",null,"then merge the conflicting PR"),e("li",null,[n("check the normal workflow merges back correctly "),e("ul",null,[e("li",null,[n("it will fail if you merged the "),e("code",null,"built"),n(" PR after the original PR")])])])],-1),D=e("h3",{id:"update-dependency-versions",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#update-dependency-versions","aria-hidden":"true"},"#"),n(" Update dependency versions")],-1),L=e("p",null,"To keep the build system as standard as possible, all dependencies need to be cached in the build image. That means that when you update the dependencies of a package, you need to update the build system as well. This can cause hard-to-test problems, because commands occasionally succeed on the dev-server but fail in production due to some quirk of GitHub Actions configuration. To minimise that risk, use the following procedure:",-1),W=o("<li>run <code>./bin/run.sh upgrade</code> in each repository <em>except</em> <code>internal-tools</code>, to run whatever upgrade commands are associated with that repo</li><li>run <code>git commit -a --reuse-message=$( git log --format=%H -1 package-lock.json )</code> in each repository from the previous step</li><li>run <code>./bin/run.sh upgrade</code> in <code>internal-tools</code>, to copy the above updates into its cache</li><li>create and accept a pull request for the changes to <code>internal-tools</code></li>",4),$=n("wait for "),z={href:"https://github.com/sleepdiary/internal-tools/actions/workflows/main.yml",target:"_blank",rel:"noopener noreferrer"},J=n("the relevant action"),K=n(" to build "),Q=e("code",null,"pre-release",-1),X=n(" versions of the build system and dev-server"),Y=n("check the new dev-server works as expected (see "),Z={href:"https://github.com/sleepdiary/internal-tools/blob/main/bin/check-dev-server.sh",target:"_blank",rel:"noopener noreferrer"},ee=e("code",null,"check-dev-server.sh",-1),ne=n(")"),te=n("push a test-commit for every repository that uses the build system (see "),ae={href:"https://github.com/sleepdiary/internal-tools/blob/main/bin/check-prerelease-build-system.sh",target:"_blank",rel:"noopener noreferrer"},oe=e("code",null,"check-prerelease-build-system.sh",-1),se=n(")"),ie=n("create a set of pull requests to apply during the planned maintenance "),re={href:"https://github.com/sleepdiary/internal-tools/compare/latest...main?expand=1",target:"_blank",rel:"noopener noreferrer"},le=n("create a pull request that pulls main into latest"),ce=e("li",null,"create a pull request for every repo you upgraded in step 1",-1);function de(he,ue){const t=i("ExternalLinkIcon");return r(),l(c,null,[h,e("p",null,[u,p,m,e("a",_,[b,a(t)]),g]),f,e("p",null,[k,e("a",y,[v,a(t)]),w]),e("p",null,[x,e("a",P,[R,a(t)]),T,q,F,j,H]),M,e("p",null,[e("a",G,[I,a(t)]),N]),O,e("ol",null,[S,A,e("li",null,[E,e("a",V,[B,a(t)]),C,U])]),D,L,e("ol",null,[W,e("li",null,[$,e("a",z,[J,a(t)]),K,Q,X]),e("li",null,[Y,e("a",Z,[ee,a(t)]),ne]),e("li",null,[te,e("a",ae,[oe,a(t)]),se]),e("li",null,[ie,e("ul",null,[e("li",null,[e("a",re,[le,a(t)])]),ce])])])],64)}var me=s(d,[["render",de]]);export{me as default};
